( structs )
|00 @command &name $2 &in-voting $1 &length

( devices )
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1

( macros )
%EMIT { #18 DEO }
%EMIT2 { #18 DEO2 }
%NL { #0a EMIT }

( zero page )
|0000
    @opt $1
    @voting $1
    @can-vote $1

( main )
|0100
    #03 .opt STZ
    ;dict/prompt print-string
    ;on-input .Console/vector DEO2 
BRK

( variables )
@votes $1024                            ( max ff options, 4 bytes each )
@input $2828 &end $2                  ( max ff options, each max 11 char + longest command name )
@ptr :input

( constants )
@commands ( name* in-voting )
    &start  :dict/start  00
    &endv   :dict/endv   01
    &next   :dict/next   01
    &vote   :dict/vote   01
    &res    :dict/res    00
    &tab    :dict/tab    00
    &end

@dict
    &start  "start 20 "vote $1 
    &endv   "end 20 "vote $1
    &next   "next 20 "voter $1
    &vote   "vote 20 $1
    &res    "add 20 "results 20 $1
    &tab    "tabulate $1
    &vinp   "Vote 20 "currently 20 "in 20 "progress $1
    &novinp "No 20 "vote 20 "in 20 "progress $1
    &unrec  "Command 20 "not 20 "recognised $1
    &prompt ">> 20 $1
    &cast   "Vote 20 "cast $1
    &verr   "Invalid 20 "vote 20 "option $1
    &notrdy "Not 20 "ready 20 "for 20 "next 20 "voter $1
    &tabln  "Votes 20 "for 20 "option 20 $1 
    &terr   "Invalid 20 "vote 20 "results 20 "provided $1
    &col    ": 20 $1

( subroutines )
@on-input                               ( called for each char after submitted via enter )
    .Console/read DEI                   ( read char )
    #0a EQU ;on-enter JCN2              ( was it enter? )
    
    ;ptr LDA2 ;input/end              ( is the command buffer full? )    
    EQU2 ,&fail JCN                     ( if so, fail )
    
    .Console/read DEI ;ptr LDA2 STA     ( save char )
    ;ptr LDA2k INC2 SWP2 STA2           ( ptr to next address )        
    BRK

    &fail
    ( TODO: fail as too long )
    ;pinl JSR2 "command 20 "too 20 "long 0a $1
BRK

@on-enter
    #00 ;ptr LDA2 STA                 	( null terminate str )
    ;input ;ptr STA2                	( reset ptr )  
    
    ;commands/start ;do-start-vote if-match     	
    ;commands/endv ;do-end-vote if-match           
    ;commands/next ;do-next-voter if-match           
    ;commands/vote ;do-vote if-match         
    ;commands/tab ;do-tabulate if-match   
    ;commands/res ;do-add-results if-match   

    ;dict/unrec print-line
    command-done

BRK

@if-match ( *command *command-func -- )
    STH2 
    DUP2 is-command #00 EQU ,&no-match JCN

    ;command/in-voting ADD2 LDA     ( if command is meant to be issued while voting )
    .voting LDZ                     ( if currently voting )
    NEQ ,&illegal JCN

    STH2r JSR2 ( execute command )
    command-done
    BRK

    &illegal
        POP2r
        ;dict/vinp ;dict/novinp .voting LDZ tertiary
        print-line
        command-done
        BRK
    &no-match
        POP2r POP2
        JMP2r

@command-done
    ;input #0b0c mclr                ( clear command buff )
    ;dict/prompt print-string
JMP2r

@is-command ( *command -- f )
    LDA2
    DUP2 slen NIP                        ( ref command length <= ff )
    ;input ROT
    seq-til                              ( does the input match the command body? )   
JMP2r

@do-start-vote    
    ( if arg not empty fail )
    reset-vote
    #01 .voting STZ    
    enable-next-voter
JMP2r

@reset-vote
    ;votes #0400 mclr        ( len of all votes = 1024 )
JMP2r

@do-end-vote
    ( if arg not empty fail )
    #00 .voting STZ    
JMP2r

@enable-next-voter
    #01 .can-vote STZ 
JMP2r

@do-next-voter
    ( if arg not empty fail )
    enable-next-voter
JMP2r

@do-vote
    .can-vote LDZ #00 EQU ,&cannot-vote JCN

    ;commands/vote arg-addr DUP2 .opt LDZ     ( get arg address )
    valid-vote-arg #00 EQU ,&invalid-arg JCN ( end if option invalid )

    sdec-to-hex NIP2 NIP                    ( choice as byte )
    choice-addr inc-at-abs                  ( cast vote )    
    ;dict/cast print-line 
    #00 .can-vote STZ 
    JMP2r   

    &invalid-arg
        POP2
        ;dict/verr print-line
        JMP2r
    &cannot-vote
        ;dict/notrdy print-line
JMP2r

@arg-addr ( *command -- arg* )
    LDA2 slen ;input ADD2                     ( ref command length + command addr = arg addr )
JMP2r

@choice-addr ( choice -- choice-addr* )
    #00 SWP                                 ( choice to short )
    #0004 MUL2 ;votes ADD2                  ( choice * 4 + votes addr = option addr )
JMP2r

@do-tabulate 
    #00 ,&c STR                            ( choice counter = 0 )
    &l
        ,&c LDR tabulate-option

        ,&c LDR INC DUP ,&c STR            ( c++ )
        .opt LDZ 
        LTH ,&l JCN
JMP2r
[ &c $1 ]

@tabulate-option ( choice )
    DUP choice-addr ROT
    ;dict/tabln print-string

    print-byte-decimal
    ;dict/col print-string
    
    lda4 print-decimal
    NL
JMP2r

@do-add-results
    valid-addres-arg ,&cont JCN              ( if args invalid, break )
    ;dict/terr print-line
    JMP2r

    &cont
    ;commands/res arg-addr ,&s STR2
    #00 ,&c STR
    &next-num
        [ LIT &c $1 ] .opt LDZ LTH
        #00 EQU ,&end JCN

        [ LIT2 &s $2 ] sdec-to-hex 
        ,&c LDR choice-addr 
        STH2k lda4 
        add32
        STH2r sta4  

        ,&c LDR INC ,&c STR ( c++ )
        ,&s LDR2 scap INC2  ( s = start of next num )
        ,&s STR2
        ,&next-num JMP

    &end
JMP2r

@valid-addres-arg ( -- f )
    ;commands/res arg-addr DUP2
    prep-arg
    ROT ROT
    .opt LDZ valid-arg-nums
    AND
    JMP2r


~/home/marton/uxn/pebble/src/functions.tal
~/home/marton/uxn/pebble/test/test-utils.tal
