( devices )
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1

( macros )
%EMIT { #18 DEO }
%EMIT2 { #18 DEO2 }
%NL { #0a EMIT }

( zero page )
|0000
    @votes [ &yes $4 &no $4 &invalid $4 ]

( main )
|0100
  ;on-input .Console/vector DEO2 
BRK

( variables )
@command $64 &end $1
@ptr :command

( constants )
@command-vote "vote 20 $1
@command-tabulate "tabulate $1

( subroutines )
@on-input                               ( called for each char after submitted via enter )
    .Console/read DEI                   ( read char )
    #0a EQU ;on-enter JCN2              ( was it enter? )
    
    ;ptr LDA2 ;command/end              ( is the command buffer full? )    
    EQU2 ,&ignore JCN                   ( if so, ignore remaining chars )
    

    .Console/read DEI ;ptr LDA2 STA     ( save char )
    ;ptr LDA2k INC2 SWP2 STA2           ( ptr to next address )        
    BRK

    &ignore
BRK

@on-enter
    #00 ;ptr LDA2 STA                 	( null terminate str )
    ;command ;ptr STA2                	( reset ptr )  
    
    ;command-vote is-command ;do-vote JCN2       	( if command vote-command, go to that subroutine )
    ;command-tabulate is-command ;do-tabulate JCN2   

    ;pinl JSR2 "command 20 "not 20 "recognised 0a $1

BRK

@is-command ( *reference command -- f )
    DUP2 slen NIP                        ( ref command length <= ff )
    ;command ROT
    seq-til                              ( does the input match the command body? )   
JMP2r

@do-vote
    ;command ;command-vote ;slen JSR2 ADD2 ( command address + command body length = arg address )
    LDA DUP                                ( load arg byte )
    option-invalid #00 EQU ,&cont JCN      ( end if option invalid )
    ;pinl JSR2 "invalid 20 "vote 20 "option 0a $1
    POP
    BRK

    &cont
    #30 SUB                                ( char -> num [0, 2] )
    #04 MUL .votes ADD                     ( opt*4 + votes addr = option zp addr )
    inc-zp                                 ( cast vote )    
    ;pinl JSR2 "vote 20 "cast 0a 0a $1
BRK

@do-tabulate 
    #03 ,&c STR         ( num of options )
    &l
        #03 #04 MUL ,&c LDR #04 MUL SUB  ( zp addr = votes len - c*8 + votes zp addr )
        #03 ,&c LDR SUB                  ( opt num = num opt - c )
        tabulate-option

        ,&c LDR #01 SUB DUP ,&c STR      ( c-- )
        #00 NEQ 
        ,&l JCN
    &end
BRK
[ &c $1 ]

@tabulate-option ( zp-addr opt-num )
    ;pinl JSR2 "Votes 20 "for 20 "option 20 $1 
    #30 ADD EMIT ;pinl JSR2 ": 20 $1
    ldz4 print-decimal
    NL
JMP2r


~/home/marton/uxn/pebble/src/functions.tal