( devices )
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1

( macros )
%EMIT { #18 DEO }
%EMIT2 { #18 DEO2 }
%NL { #0a EMIT }

( zero page )
|0000
    @opt $1
    @votes [ &yes $4 &no $4 &invalid $4 ]

( main )
|0100
    #03 .opt STZ
    ;on-input .Console/vector DEO2 
BRK

( variables )
@command $64 &end $2
@ptr :command

( constants )
@command-vote "vote 20 $1
@command-addres "add-results 20 $1
@command-tabulate "tabulate $1

( subroutines )
@on-input                               ( called for each char after submitted via enter )
    .Console/read DEI                   ( read char )
    #0a EQU ;on-enter JCN2              ( was it enter? )
    
    ;ptr LDA2 ;command/end              ( is the command buffer full? )    
    EQU2 ,&ignore JCN                   ( if so, ignore remaining chars )
    

    .Console/read DEI ;ptr LDA2 STA     ( save char )
    ;ptr LDA2k INC2 SWP2 STA2           ( ptr to next address )        
    BRK

    &ignore
BRK

@on-enter
    #00 ;ptr LDA2 STA                 	( null terminate str )
    ;command ;ptr STA2                	( reset ptr )  
    
    ;command-vote is-command ;do-vote JCN2       	( if command vote-command, go to that subroutine )
    ;command-tabulate is-command ;do-tabulate JCN2   
    ;command-addres is-command ;do-add-results JCN2   

    ( TODO: clear command buff )

    ;pinl JSR2 "command 20 "not 20 "recognised 0a $1

BRK

@is-command ( *reference command -- f )
    DUP2 slen NIP                        ( ref command length <= ff )
    ;command ROT
    seq-til                              ( does the input match the command body? )   
JMP2r

@do-vote
    ;command-vote arg-addr                 ( get arg address )
    LDA DUP                                ( load arg byte )
    option-invalid #00 EQU ,&cont JCN      ( end if option invalid )
    ;pinl JSR2 "invalid 20 "vote 20 "option 0a $1
    POP
    BRK

    &cont
    #30 SUB                                ( char -> num [0, 2] )
    #04 MUL .votes ADD                     ( opt*4 + votes addr = option zp addr )
    inc-zp                                 ( cast vote )    
    ;pinl JSR2 "vote 20 "cast 0a 0a $1
BRK

@arg-addr ( *reference command -- arg* )
    slen ;command ADD2                     ( ref command length + command addr = arg addr )
JMP2r

@do-tabulate 
    #00 ,&c STR         ( num of options )
    &l
        ,&c LDR #04 MUL .votes ADD       ( zp addr = votes len - c*4 + votes zp addr )
        ,&c LDR                   
        tabulate-option

        ,&c LDR INC DUP ,&c STR      ( c++ )
        .opt LDZ 
        LTH ,&l JCN
    &end
    NL
BRK
[ &c $1 ]


@tabulate-option ( zp-addr opt-num )
    ;pinl JSR2 "Votes 20 "for 20 "option 20 $1 
    #30 ADD EMIT ;pinl JSR2 ": 20 $1
    ldz4 print-decimal
    NL
JMP2r

( how long can arg max be? ...; 11 chars * 9 options = 99 chars -> 99 bytes )
@do-add-results 
    valid-addres-arg ,&cont JCN              ( if args invalid, break )
    ;pinl JSR2 "invalid 20 "vote 20 "results 20 "provided 0a $1
    BRK

    &cont
    ;command-addres arg-addr ,&s STR2
    #00 ,&c STR
    &next-num
        [ LIT &c $1 ] .opt LDZ LTH
        #00 EQU ,&end JCN

        [ LIT2 &s $2 ] sdec-to-hex
        ,&c LDR #04 MUL .votes ADD
        STHk ldz4
        add32
        STHr stz4

        ,&c LDR INC ,&c STR ( c++ )
        ,&s LDR2 scap INC2  ( s = start of next num )
        ,&s STR2
        ,&next-num JMP

    &end
BRK

@valid-addres-arg ( -- f )
    ;command-addres arg-addr DUP2
    prep-arg
    ROT ROT
    .opt LDZ valid-arg-nums
    AND
    JMP2r


~/home/marton/uxn/pebble/src/functions.tal