( devices )
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1

( macros )
%EMIT { #18 DEO }
%EMIT2 { #18 DEO2 }
%NL { #0a EMIT }

( zero page )
|0000
    @opt $1
    @voting $1
    @can-vote $1

( main )
|0100
    #03 .opt STZ
    ;on-input .Console/vector DEO2 
BRK

( variables )
@votes $1024                            ( max ff options, 4 bytes each )
@command $2828 &end $2                  ( max ff options, each max 11 char + longest command name )
@ptr :command

( constants )
@command-start "start 20 "vote $1
@command-end "end 20 "vote $1
@command-next "next 20 "voter $1
@command-vote "vote 20 $1
@command-addres "add 20 "results 20 $1
@command-tabulate "tabulate $1

( subroutines )
@on-input                               ( called for each char after submitted via enter )
    .Console/read DEI                   ( read char )
    #0a EQU ;on-enter JCN2              ( was it enter? )
    
    ;ptr LDA2 ;command/end              ( is the command buffer full? )    
    EQU2 ,&fail JCN                     ( if so, fail )
    
    .Console/read DEI ;ptr LDA2 STA     ( save char )
    ;ptr LDA2k INC2 SWP2 STA2           ( ptr to next address )        
    BRK

    &fail
    ( TODO: fail as too long )
    ;pinl JSR2 "command 20 "too 20 "long 0a $1
BRK

@on-enter
    #00 ;ptr LDA2 STA                 	( null terminate str )
    ;command ;ptr STA2                	( reset ptr )  
    
    ;command-start is-command ;do-start-vote JCN2       	
    ;command-end is-command ;do-end-vote JCN2           
    ;command-next is-command ;do-next-voter JCN2           
    ;command-vote is-command ;do-vote JCN2          ( if command vote-command, go to that subroutine )
    ;command-tabulate is-command ;do-tabulate JCN2   
    ;command-addres is-command ;do-add-results JCN2   

    ( TODO: clear command buff )

    ;pinl JSR2 "command 20 "not 20 "recognised 0a $1

BRK

@is-command ( *reference command -- f )
    DUP2 slen NIP                        ( ref command length <= ff )
    ;command ROT
    seq-til                              ( does the input match the command body? )   
JMP2r

@do-start-vote
    .voting LDZ ,&vote-in-p JCN
    
    ( if arg not empty fail )
    reset-vote
    #01 .voting STZ    
    enable-next-voter
    BRK

    &vote-in-p
        ;pinl JSR2 "Vote 20 "currently 20 "in 20 "progress 0a $1
BRK

@reset-vote
    ;votes #0400 mclr        ( len of all votes = 1024 )
JMP2r

@do-end-vote
    .voting LDZ #00 EQU ,&not-voting JCN

    ( if arg not empty fail )
    #00 .voting STZ    
    BRK

    &not-voting
        ;pinl JSR2 "No 20 "vote 20 "in 20 "progress 0a $1
BRK

@enable-next-voter
    #01 .can-vote STZ 
JMP2r

@do-next-voter
    .voting LDZ #00 EQU ,&not-voting JCN
    
    ( if arg not empty fail )
    enable-next-voter
    BRK

    &not-voting
        ;pinl JSR2 "No 20 "vote 20 "in 20 "progress 0a $1
BRK

@do-vote
    .voting LDZ #00 EQU ,&not-voting JCN
    .can-vote LDZ #00 EQU ,&cannot-vote JCN

    ;command-vote arg-addr DUP2 .opt LDZ     ( get arg address )
    valid-vote-arg #00 EQU ,&invalid-arg JCN ( end if option invalid )

    sdec-to-hex NIP2 NIP                    ( choice as byte )
    choice-addr inc-at-abs                  ( cast vote )    
    ;pinl JSR2 "vote 20 "cast 0a 0a $1
    #00 .can-vote STZ 
    BRK   

    &invalid-arg
        POP2
        ;pinl JSR2 "invalid 20 "vote 20 "option 0a $1
        BRK
    &not-voting
        ;pinl JSR2 "No 20 "vote 20 "in 20 "progress 0a $1
        BRK
    &cannot-vote
        ;pinl JSR2 "Not 20 "ready 20 "for 20 "next 20 "voter 0a $1
BRK

@arg-addr ( *reference command -- arg* )
    slen ;command ADD2                     ( ref command length + command addr = arg addr )
JMP2r

@choice-addr ( choice -- choice-addr* )
    #00 SWP                                 ( choice to short )
    #0004 MUL2 ;votes ADD2                  ( choice * 4 + votes addr = option addr )
JMP2r

@do-tabulate 
    .voting LDZ ,&vote-in-p JCN

    #00 ,&c STR                            ( choice counter = 0 )
    &l
        ,&c LDR tabulate-option

        ,&c LDR INC DUP ,&c STR            ( c++ )
        .opt LDZ 
        LTH ,&l JCN
    NL
    BRK

    &vote-in-p
        ;pinl JSR2 "Vote 20 "currently 20 "in 20 "progress 0a $1
BRK
[ &c $1 ]

@tabulate-option ( choice )
    DUP choice-addr ROT
    ;pinl JSR2 "Votes 20 "for 20 "option 20 $1 

    print-byte-decimal
    ;pinl JSR2 ": 20 $1
    
    lda4 print-decimal
    NL
JMP2r

@do-add-results
    .voting LDZ ,&vote-in-p JCN

    valid-addres-arg ,&cont JCN              ( if args invalid, break )
    ;pinl JSR2 "invalid 20 "vote 20 "results 20 "provided 0a $1
    BRK

    &cont
    ;command-addres arg-addr ,&s STR2
    #00 ,&c STR
    &next-num
        [ LIT &c $1 ] .opt LDZ LTH
        #00 EQU ,&end JCN

        [ LIT2 &s $2 ] sdec-to-hex 
        ,&c LDR choice-addr 
        STH2k lda4 
        add32
        STH2r sta4  

        ,&c LDR INC ,&c STR ( c++ )
        ,&s LDR2 scap INC2  ( s = start of next num )
        ,&s STR2
        ,&next-num JMP

    &end
        BRK

    &vote-in-p
        ;pinl JSR2 "Vote 20 "currently 20 "in 20 "progress 0a $1
BRK

@valid-addres-arg ( -- f )
    ;command-addres arg-addr DUP2
    prep-arg
    ROT ROT
    .opt LDZ valid-arg-nums
    AND
    JMP2r


~/home/marton/uxn/pebble/src/functions.tal
